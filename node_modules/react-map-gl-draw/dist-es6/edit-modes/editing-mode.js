"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _editModes = require("@nebula.gl/edit-modes");

var _constants = require("../constants");

var _baseMode = _interopRequireDefault(require("./base-mode"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var EditingMode = /*#__PURE__*/function (_BaseMode) {
  _inherits(EditingMode, _BaseMode);

  var _super = _createSuper(EditingMode);

  function EditingMode() {
    _classCallCheck(this, EditingMode);

    return _super.apply(this, arguments);
  }

  _createClass(EditingMode, [{
    key: "handleClick",
    value: function handleClick(event, props) {
      var picked = event.picks && event.picks[0];
      var selectedFeatureIndex = props.selectedIndexes && props.selectedIndexes[0]; // @ts-ignore

      if (!picked || !picked.object || picked.featureIndex !== selectedFeatureIndex) {
        return;
      } // @ts-ignore


      var objectType = picked.type,
          featureIndex = picked.featureIndex,
          index = picked.index;
      var feature = this.getSelectedFeature(props, featureIndex);

      if (feature && (feature.geometry.type === _constants.GEOJSON_TYPE.POLYGON || feature.geometry.type === _constants.GEOJSON_TYPE.LINE_STRING) && objectType === _constants.ELEMENT_TYPE.SEGMENT) {
        var coordinates = (0, _utils.getFeatureCoordinates)(feature);

        if (!coordinates) {
          return;
        } // @ts-ignore


        var insertIndex = (index + 1) % coordinates.length;
        var positionIndexes = feature.geometry.type === _constants.SHAPE.POLYGON ? [0, insertIndex] : [insertIndex];

        var insertMapCoords = this._getPointOnSegment(feature, picked, event.mapCoords);

        var updatedData = new _editModes.ImmutableFeatureCollection(props.data) // @ts-ignore
        .addPosition(featureIndex, positionIndexes, insertMapCoords).getObject();
        props.onEdit({
          editType: _constants.EDIT_TYPE.ADD_POSITION,
          updatedData: updatedData,
          editContext: [{
            featureIndex: featureIndex,
            editHandleIndex: insertIndex,
            // @ts-ignore
            screenCoords: props.viewport && props.viewport.project(insertMapCoords),
            mapCoords: insertMapCoords
          }]
        });
      }
    }
  }, {
    key: "handleStopDragging",
    value: function handleStopDragging(event, props) {
      // replace point
      var picked = event.picks && event.picks[0]; // @ts-ignore

      if (!picked || !picked.Object || !(0, _utils.isNumeric)(picked.featureIndex)) {
        return;
      }

      var pickedObject = picked.object;

      switch (pickedObject.type) {
        case _constants.ELEMENT_TYPE.FEATURE:
        case _constants.ELEMENT_TYPE.FILL:
        case _constants.ELEMENT_TYPE.EDIT_HANDLE:
          this._handleDragging(event, props);

          break;

        default:
      }
    }
  }, {
    key: "_handleDragging",
    value: function _handleDragging(event, props) {
      var onEdit = props.onEdit; // @ts-ignore

      var selectedFeature = this.getSelectedFeature(props); // nothing clicked
      // @ts-ignore

      var isDragging = event.isDragging,
          pointerDownPicks = event.pointerDownPicks,
          screenCoords = event.screenCoords;
      var lastPointerMoveEvent = props.lastPointerMoveEvent;
      var clicked = pointerDownPicks && pointerDownPicks[0]; // @ts-ignore

      if (!clicked || !clicked.object || !(0, _utils.isNumeric)(clicked.featureIndex)) {
        return;
      } // @ts-ignore


      var objectType = clicked.type,
          editHandleIndex = clicked.index; // not dragging

      var updatedData = null;
      var editType = isDragging ? _constants.EDIT_TYPE.MOVE_POSITION : _constants.EDIT_TYPE.FINISH_MOVE_POSITION;

      switch (objectType) {
        case _constants.ELEMENT_TYPE.FEATURE:
        case _constants.ELEMENT_TYPE.FILL:
        case _constants.ELEMENT_TYPE.SEGMENT:
          if (!props.featuresDraggable) {
            break;
          } // dragging feature


          var dx = screenCoords[0] - lastPointerMoveEvent.screenCoords[0];
          var dy = screenCoords[1] - lastPointerMoveEvent.screenCoords[1];
          updatedData = this._updateFeature(props, 'feature', {
            dx: dx,
            dy: dy
          });
          onEdit({
            editType: editType,
            updatedData: updatedData,
            editContext: null
          });
          break;

        case _constants.ELEMENT_TYPE.EDIT_HANDLE:
          // dragging editHandle
          // dragging rectangle or other shapes
          var updateType = selectedFeature.properties.shape === _constants.SHAPE.RECTANGLE ? 'rectangle' : 'editHandle';
          updatedData = this._updateFeature(props, updateType, {
            editHandleIndex: editHandleIndex,
            mapCoords: event.mapCoords
          });
          onEdit({
            editType: editType,
            updatedData: updatedData,
            editContext: null
          });
          break;

        default:
      }
    }
  }, {
    key: "handlePointerMove",
    value: function handlePointerMove(event, props) {
      // no selected feature
      // @ts-ignore
      var selectedFeature = this.getSelectedFeature(props);

      if (!selectedFeature) {
        return;
      } // @ts-ignore


      if (!event.isDragging) {
        return;
      }

      this._handleDragging(event, props);
    } // TODO - refactor

  }, {
    key: "_updateFeature",
    value: function _updateFeature(props, type) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var data = props.data,
          selectedIndexes = props.selectedIndexes,
          viewport = props.viewport;
      var featureIndex = selectedIndexes && selectedIndexes[0];
      var feature = this.getSelectedFeature(props, featureIndex);
      var geometry = null;
      var coordinates = (0, _utils.getFeatureCoordinates)(feature);

      if (!coordinates) {
        return null;
      } // @ts-ignore


      var newCoordinates = _toConsumableArray(coordinates);

      switch (type) {
        case 'editHandle':
          var positionIndexes = feature.geometry.type === _constants.GEOJSON_TYPE.POLYGON ? [0, options.editHandleIndex] : [options.editHandleIndex];
          return new _editModes.ImmutableFeatureCollection(data).replacePosition(featureIndex, positionIndexes, options.mapCoords).getObject();

        case 'feature':
          var dx = options.dx,
              dy = options.dy; // @ts-ignore

          newCoordinates = newCoordinates.map(function (mapCoords) {
            // @ts-ignore
            var pixels = viewport && viewport.project(mapCoords);

            if (pixels) {
              pixels[0] += dx;
              pixels[1] += dy;
              return viewport && viewport.unproject(pixels);
            }

            return null;
          }).filter(Boolean);
          geometry = {
            type: feature.geometry.type,
            coordinates: feature.geometry.type === _constants.GEOJSON_TYPE.POLYGON ? [newCoordinates] : feature.geometry.type === _constants.GEOJSON_TYPE.POINT ? newCoordinates[0] : newCoordinates
          };
          return new _editModes.ImmutableFeatureCollection(data).replaceGeometry(featureIndex, geometry).getObject();

        case 'rectangle':
          // moved editHandleIndex and destination mapCoords
          newCoordinates = (0, _utils.updateRectanglePosition)( // @ts-ignore
          feature, options.editHandleIndex, options.mapCoords);
          geometry = {
            type: _constants.GEOJSON_TYPE.POLYGON,
            coordinates: newCoordinates
          };
          return new _editModes.ImmutableFeatureCollection(data).replaceGeometry(featureIndex, geometry).getObject();

        default:
          return data && new _editModes.ImmutableFeatureCollection(data).getObject();
      }
    }
  }, {
    key: "_getPointOnSegment",
    value: function _getPointOnSegment(feature, picked, pickedMapCoords) {
      var coordinates = (0, _utils.getFeatureCoordinates)(feature);

      if (!coordinates) {
        return null;
      }

      var srcVertexIndex = picked.index;
      var targetVertexIndex = picked.index + 1;
      return (0, _utils.findClosestPointOnLineSegment)( // @ts-ignore
      coordinates[srcVertexIndex], coordinates[targetVertexIndex], pickedMapCoords);
    }
  }, {
    key: "_getCursorEditHandle",
    value: function _getCursorEditHandle(event, feature) {
      // event can be null when the user has not interacted with the map whatsoever
      // and therefore props.lastPointerMoveEvent is still null
      // returning null here means we can e.g. set a featureIndex without requiring an event
      if (!event) {
        return null;
      } // @ts-ignore


      var isDragging = event.isDragging,
          picks = event.picks; // if not pick segment

      var picked = picks && picks[0]; // @ts-ignore

      if (!picked || !(0, _utils.isNumeric)(picked.featureIndex) || picked.type !== _constants.ELEMENT_TYPE.SEGMENT) {
        return null;
      } // if dragging or feature is neither polygon nor line string


      if (isDragging || feature.geometry.type !== _constants.GEOJSON_TYPE.POLYGON && feature.geometry.type !== _constants.GEOJSON_TYPE.LINE_STRING) {
        return null;
      }

      var insertMapCoords = this._getPointOnSegment(feature, picked, event.mapCoords);

      if (!insertMapCoords) {
        return null;
      }

      return {
        type: 'Feature',
        properties: {
          guideType: _constants.GUIDE_TYPE.CURSOR_EDIT_HANDLE,
          shape: feature.properties.shape,
          positionIndexes: [-1],
          editHandleType: 'intermediate'
        },
        geometry: {
          type: _constants.GEOJSON_TYPE.POINT,
          coordinates: insertMapCoords
        }
      };
    } // @ts-ignore

  }, {
    key: "getGuides",
    value: function getGuides(props) {
      // @ts-ignore
      var selectedFeature = this.getSelectedFeature(props);
      var selectedFeatureIndex = props.selectedIndexes && props.selectedIndexes[0];

      if (!selectedFeature || selectedFeature.geometry.type === _constants.GEOJSON_TYPE.POINT) {
        return null;
      }

      var event = props.lastPointerMoveEvent; // feature editHandles

      var editHandles = this.getEditHandlesFromFeature(selectedFeature, selectedFeatureIndex) || []; // cursor editHandle

      var cursorEditHandle = this._getCursorEditHandle(event, selectedFeature);

      if (cursorEditHandle) {
        // @ts-ignore
        editHandles.push(cursorEditHandle);
      }

      return {
        type: 'FeatureCollection',
        features: editHandles.length ? editHandles : null
      };
    }
  }]);

  return EditingMode;
}(_baseMode["default"]);

exports["default"] = EditingMode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lZGl0LW1vZGVzL2VkaXRpbmctbW9kZS50cyJdLCJuYW1lcyI6WyJFZGl0aW5nTW9kZSIsImV2ZW50IiwicHJvcHMiLCJwaWNrZWQiLCJwaWNrcyIsInNlbGVjdGVkRmVhdHVyZUluZGV4Iiwic2VsZWN0ZWRJbmRleGVzIiwib2JqZWN0IiwiZmVhdHVyZUluZGV4Iiwib2JqZWN0VHlwZSIsInR5cGUiLCJpbmRleCIsImZlYXR1cmUiLCJnZXRTZWxlY3RlZEZlYXR1cmUiLCJnZW9tZXRyeSIsIkdFT0pTT05fVFlQRSIsIlBPTFlHT04iLCJMSU5FX1NUUklORyIsIkVMRU1FTlRfVFlQRSIsIlNFR01FTlQiLCJjb29yZGluYXRlcyIsImluc2VydEluZGV4IiwibGVuZ3RoIiwicG9zaXRpb25JbmRleGVzIiwiU0hBUEUiLCJpbnNlcnRNYXBDb29yZHMiLCJfZ2V0UG9pbnRPblNlZ21lbnQiLCJtYXBDb29yZHMiLCJ1cGRhdGVkRGF0YSIsIkltbXV0YWJsZUZlYXR1cmVDb2xsZWN0aW9uIiwiZGF0YSIsImFkZFBvc2l0aW9uIiwiZ2V0T2JqZWN0Iiwib25FZGl0IiwiZWRpdFR5cGUiLCJFRElUX1RZUEUiLCJBRERfUE9TSVRJT04iLCJlZGl0Q29udGV4dCIsImVkaXRIYW5kbGVJbmRleCIsInNjcmVlbkNvb3JkcyIsInZpZXdwb3J0IiwicHJvamVjdCIsIk9iamVjdCIsInBpY2tlZE9iamVjdCIsIkZFQVRVUkUiLCJGSUxMIiwiRURJVF9IQU5ETEUiLCJfaGFuZGxlRHJhZ2dpbmciLCJzZWxlY3RlZEZlYXR1cmUiLCJpc0RyYWdnaW5nIiwicG9pbnRlckRvd25QaWNrcyIsImxhc3RQb2ludGVyTW92ZUV2ZW50IiwiY2xpY2tlZCIsIk1PVkVfUE9TSVRJT04iLCJGSU5JU0hfTU9WRV9QT1NJVElPTiIsImZlYXR1cmVzRHJhZ2dhYmxlIiwiZHgiLCJkeSIsIl91cGRhdGVGZWF0dXJlIiwidXBkYXRlVHlwZSIsInByb3BlcnRpZXMiLCJzaGFwZSIsIlJFQ1RBTkdMRSIsIm9wdGlvbnMiLCJuZXdDb29yZGluYXRlcyIsInJlcGxhY2VQb3NpdGlvbiIsIm1hcCIsInBpeGVscyIsInVucHJvamVjdCIsImZpbHRlciIsIkJvb2xlYW4iLCJQT0lOVCIsInJlcGxhY2VHZW9tZXRyeSIsInBpY2tlZE1hcENvb3JkcyIsInNyY1ZlcnRleEluZGV4IiwidGFyZ2V0VmVydGV4SW5kZXgiLCJndWlkZVR5cGUiLCJHVUlERV9UWVBFIiwiQ1VSU09SX0VESVRfSEFORExFIiwiZWRpdEhhbmRsZVR5cGUiLCJlZGl0SGFuZGxlcyIsImdldEVkaXRIYW5kbGVzRnJvbUZlYXR1cmUiLCJjdXJzb3JFZGl0SGFuZGxlIiwiX2dldEN1cnNvckVkaXRIYW5kbGUiLCJwdXNoIiwiZmVhdHVyZXMiLCJCYXNlTW9kZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQVdBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQU9xQkEsVzs7Ozs7Ozs7Ozs7OztnQ0FDUEMsSyxFQUFtQkMsSyxFQUFxQztBQUNsRSxVQUFNQyxNQUFNLEdBQUdGLEtBQUssQ0FBQ0csS0FBTixJQUFlSCxLQUFLLENBQUNHLEtBQU4sQ0FBWSxDQUFaLENBQTlCO0FBQ0EsVUFBTUMsb0JBQW9CLEdBQUdILEtBQUssQ0FBQ0ksZUFBTixJQUF5QkosS0FBSyxDQUFDSSxlQUFOLENBQXNCLENBQXRCLENBQXRELENBRmtFLENBR2xFOztBQUNBLFVBQUksQ0FBQ0gsTUFBRCxJQUFXLENBQUNBLE1BQU0sQ0FBQ0ksTUFBbkIsSUFBNkJKLE1BQU0sQ0FBQ0ssWUFBUCxLQUF3Qkgsb0JBQXpELEVBQStFO0FBQzdFO0FBQ0QsT0FOaUUsQ0FRbEU7OztBQVJrRSxVQVNwREksVUFUb0QsR0FTaEJOLE1BVGdCLENBUzFETyxJQVQwRDtBQUFBLFVBU3hDRixZQVR3QyxHQVNoQkwsTUFUZ0IsQ0FTeENLLFlBVHdDO0FBQUEsVUFTMUJHLEtBVDBCLEdBU2hCUixNQVRnQixDQVMxQlEs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QUNpRCxvQkFBcEIsQ0FUNkMsQ0FXN0M7O0FBQ0EsVUFBTTZCLFdBQVcsR0FBRyxLQUFLQyx5QkFBTCxDQUErQmpDLGVBQS9CLEVBQWdEM0Msb0JBQWhELEtBQXlFLEVBQTdGLENBWjZDLENBYzdDOztBQUNBLFVBQU02RSxnQkFBZ0IsR0FBRyxLQUFLQyxvQkFBTCxDQUEwQmxGLEtBQTFCLEVBQWlDK0MsZUFBakMsQ0FBekI7O0FBQ0EsVUFBSWtDLGdCQUFKLEVBQXNCO0FBQ3BCO0FBQ0FGLFFBQUFBLFdBQVcsQ0FBQ0ksSUFBWixDQUFpQkYsZ0JBQWpCO0FBQ0Q7O0FBRUQsYUFBTztBQUNMeEUsUUFBQUEsSUFBSSxFQUFFLG1CQUREO0FBRUwyRSxRQUFBQSxRQUFRLEVBQUVMLFdBQVcsQ0FBQzFELE1BQVosR0FBcUIwRCxXQUFyQixHQUFtQztBQUZ4QyxPQUFQO0FBSUQ7Ozs7RUEzVHNDTSxvQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEltbXV0YWJsZUZlYXR1cmVDb2xsZWN0aW9uIH0gZnJvbSAnQG5lYnVsYS5nbC9lZGl0LW1vZGVzJztcbmltcG9ydCB0eXBlIHtcbiAgRmVhdHVyZSxcbiAgRmVhdHVyZUNvbGxlY3Rpb24sXG4gIENsaWNrRXZlbnQsXG4gIFN0b3BEcmFnZ2luZ0V2ZW50LFxuICBQb2ludGVyTW92ZUV2ZW50LFxuICBQb3NpdGlvbixcbn0gZnJvbSAnQG5lYnVsYS5nbC9lZGl0LW1vZGVzJztcbmltcG9ydCB7IE1vZGVQcm9wcyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgU0hBUEUsIEVESVRfVFlQRSwgRUxFTUVOVF9UWVBFLCBHRU9KU09OX1RZUEUsIEdVSURFX1RZUEUgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IEJhc2VNb2RlIGZyb20gJy4vYmFzZS1tb2RlJztcbmltcG9ydCB7XG4gIGZpbmRDbG9zZXN0UG9pbnRPbkxpbmVTZWdtZW50LFxuICBnZXRGZWF0dXJlQ29vcmRpbmF0ZXMsXG4gIGlzTnVtZXJpYyxcbiAgdXBkYXRlUmVjdGFuZ2xlUG9zaXRpb24sXG59IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFZGl0aW5nTW9kZSBleHRlbmRzIEJhc2VNb2RlIHtcbiAgaGFuZGxlQ2xpY2soZXZlbnQ6IENsaWNrRXZlbnQsIHByb3BzOiBNb2RlUHJvcHM8RmVhdHVyZUNvbGxlY3Rpb24+KSB7XG4gICAgY29uc3QgcGlja2VkID0gZXZlbnQucGlja3MgJiYgZXZlbnQucGlja3NbMF07XG4gICAgY29uc3Qgc2VsZWN0ZWRGZWF0dXJlSW5kZXggPSBwcm9wcy5zZWxlY3RlZEluZGV4ZXMgJiYgcHJvcHMuc2VsZWN0ZWRJbmRleGVzWzBdO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoIXBpY2tlZCB8fCAhcGlja2VkLm9iamVjdCB8fCBwaWNrZWQuZmVhdHVyZUluZGV4ICE9PSBzZWxlY3RlZEZlYXR1cmVJbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCB7IHR5cGU6IG9iamVjdFR5cGUsIGZlYXR1cmVJbmRleCwgaW5kZXggfSA9IHBpY2tlZDtcbiAgICBjb25zdCBmZWF0dXJlID0gdGhpcy5nZXRTZWxlY3RlZEZlYXR1cmUocHJvcHMsIGZlYXR1cmVJbmRleCk7XG5cbiAgICBpZiAoXG4gICAgICBmZWF0dXJlICYmXG4gICAgICAoZmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSBHRU9KU09OX1RZUEUuUE9MWUdPTiB8fFxuICAgICAgICBmZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT09IEdFT0pTT05fVFlQRS5MSU5FX1NUUklORykgJiZcbiAgICAgIG9iamVjdFR5cGUgPT09IEVMRU1FTlRfVFlQRS5TRUdNRU5UXG4gICAgKSB7XG4gICAgICBjb25zdCBjb29yZGluYXRlcyA9IGdldEZlYXR1cmVDb29yZGluYXRlcyhmZWF0dXJlKTtcbiAgICAgIGlmICghY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgY29uc3QgaW5zZXJ0SW5kZXggPSAoaW5kZXggKyAxKSAlIGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgIGNvbnN0IHBvc2l0aW9uSW5kZXhlcyA9XG4gICAgICAgIGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gU0hBUEUuUE9MWUdPTiA/IFswLCBpbnNlcnRJbmRleF0gOiBbaW5zZXJ0SW5kZXhdO1xuICAgICAgY29uc3QgaW5zZXJ0TWFwQ29vcmRzID0gdGhpcy5fZ2V0UG9pbnRPblNlZ21lbnQoZmVhdHVyZSwgcGlja2VkLCBldmVudC5tYXBDb29yZHMpO1xuXG4gICAgICBjb25zdCB1cGRhdGVkRGF0YSA9IG5ldyBJbW11dGFibGVGZWF0dXJlQ29sbGVjdGlvbihwcm9wcy5kYXRhKVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIC5hZGRQb3NpdGlvbihmZWF0dXJlSW5kZXgsIHBvc2l0aW9uSW5kZXhlcywgaW5zZXJ0TWFwQ29vcmRzKVxuICAgICAgICAuZ2V0T2JqZWN0KCk7XG5cbiAgICAgIHByb3BzLm9uRWRpdCh7XG4gICAgICAgIGVkaXRUeXBlOiBFRElUX1RZUEUuQUREX1BPU0lUSU9OLFxuICAgICAgICB1cGRhdGVkRGF0YSxcbiAgICAgICAgZWRpdENvbnRleHQ6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBmZWF0dXJlSW5kZXgsXG4gICAgICAgICAgICBlZGl0SGFuZGxlSW5kZXg6IGluc2VydEluZGV4LFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgc2NyZWVuQ29vcmRzOiBwcm9wcy52aWV3cG9ydCAmJiBwcm9wcy52aWV3cG9ydC5wcm9qZWN0KGluc2VydE1hcENvb3JkcyksXG4gICAgICAgICAgICBtYXBDb29yZHM6IGluc2VydE1hcENvb3JkcyxcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlU3RvcERyYWdnaW5nKGV2ZW50OiBTdG9wRHJhZ2dpbmdFdmVudCwgcHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pIHtcbiAgICAvLyByZXBsYWNlIHBvaW50XG4gICAgY29uc3QgcGlja2VkID0gZXZlbnQucGlja3MgJiYgZXZlbnQucGlja3NbMF07XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKCFwaWNrZWQgfHwgIXBpY2tlZC5PYmplY3QgfHwgIWlzTnVtZXJpYyhwaWNrZWQuZmVhdHVyZUluZGV4KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBpY2tlZE9iamVjdCA9IHBpY2tlZC5vYmplY3Q7XG4gICAgc3dpdGNoIChwaWNrZWRPYmplY3QudHlwZSkge1xuICAgICAgY2FzZSBFTEVNRU5UX1RZUEUuRkVBVFVSRTpcbiAgICAgIGNhc2UgRUxFTUVOVF9UWVBFLkZJTEw6XG4gICAgICBjYXNlIEVMRU1FTlRfVFlQRS5FRElUX0hBTkRMRTpcbiAgICAgICAgdGhpcy5faGFuZGxlRHJhZ2dpbmcoZXZlbnQsIHByb3BzKTtcblxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZURyYWdnaW5nKFxuICAgIGV2ZW50OiBQb2ludGVyTW92ZUV2ZW50IHwgU3RvcERyYWdnaW5nRXZlbnQsXG4gICAgcHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj5cbiAgKSB7XG4gICAgY29uc3QgeyBvbkVkaXQgfSA9IHByb3BzO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBzZWxlY3RlZEZlYXR1cmUgPSB0aGlzLmdldFNlbGVjdGVkRmVhdHVyZShwcm9wcyk7XG4gICAgLy8gbm90aGluZyBjbGlja2VkXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IHsgaXNEcmFnZ2luZywgcG9pbnRlckRvd25QaWNrcywgc2NyZWVuQ29vcmRzIH0gPSBldmVudDtcbiAgICBjb25zdCB7IGxhc3RQb2ludGVyTW92ZUV2ZW50IH0gPSBwcm9wcztcblxuICAgIGNvbnN0IGNsaWNrZWQgPSBwb2ludGVyRG93blBpY2tzICYmIHBvaW50ZXJEb3duUGlja3NbMF07XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmICghY2xpY2tlZCB8fCAhY2xpY2tlZC5vYmplY3QgfHwgIWlzTnVtZXJpYyhjbGlja2VkLmZlYXR1cmVJbmRleCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgeyB0eXBlOiBvYmplY3RUeXBlLCBpbmRleDogZWRpdEhhbmRsZUluZGV4IH0gPSBjbGlja2VkO1xuXG4gICAgLy8gbm90IGRyYWdnaW5nXG4gICAgbGV0IHVwZGF0ZWREYXRhID0gbnVsbDtcbiAgICBjb25zdCBlZGl0VHlwZSA9IGlzRHJhZ2dpbmcgPyBFRElUX1RZUEUuTU9WRV9QT1NJVElPTiA6IEVESVRfVFlQRS5GSU5JU0hfTU9WRV9QT1NJVElPTjtcblxuICAgIHN3aXRjaCAob2JqZWN0VHlwZSkge1xuICAgICAgY2FzZSBFTEVNRU5UX1RZUEUuRkVBVFVSRTpcbiAgICAgIGNhc2UgRUxFTUVOVF9UWVBFLkZJTEw6XG4gICAgICBjYXNlIEVMRU1FTlRfVFlQRS5TRUdNRU5UOlxuICAgICAgICBpZiAoIXByb3BzLmZlYXR1cmVzRHJhZ2dhYmxlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gLy8gZHJhZ2dpbmcgZmVhdHVyZVxuXG4gICAgICAgIGNvbnN0IGR4ID0gc2NyZWVuQ29vcmRzWzBdIC0gbGFzdFBvaW50ZXJNb3ZlRXZlbnQuc2NyZWVuQ29vcmRzWzBdO1xuICAgICAgICBjb25zdCBkeSA9IHNjcmVlbkNvb3Jkc1sxXSAtIGxhc3RQb2ludGVyTW92ZUV2ZW50LnNjcmVlbkNvb3Jkc1sxXTtcbiAgICAgICAgdXBkYXRlZERhdGEgPSB0aGlzLl91cGRhdGVGZWF0dXJlKHByb3BzLCAnZmVhdHVyZScsIHsgZHgsIGR5IH0pO1xuICAgICAgICBvbkVkaXQoe1xuICAgICAgICAgIGVkaXRUeXBlLFxuICAgICAgICAgIHVwZGF0ZWREYXRhLFxuICAgICAgICAgIGVkaXRDb250ZXh0OiBudWxsLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRUxFTUVOVF9UWVBFLkVESVRfSEFORExFOlxuICAgICAgICAvLyBkcmFnZ2luZyBlZGl0SGFuZGxlXG4gICAgICAgIC8vIGRyYWdnaW5nIHJlY3RhbmdsZSBvciBvdGhlciBzaGFwZXNcbiAgICAgICAgY29uc3QgdXBkYXRlVHlwZSA9XG4gICAgICAgICAgc2VsZWN0ZWRGZWF0dXJlLnByb3BlcnRpZXMuc2hhcGUgPT09IFNIQVBFLlJFQ1RBTkdMRSA/ICdyZWN0YW5nbGUnIDogJ2VkaXRIYW5kbGUnO1xuICAgICAgICB1cGRhdGVkRGF0YSA9IHRoaXMuX3VwZGF0ZUZlYXR1cmUocHJvcHMsIHVwZGF0ZVR5cGUsIHtcbiAgICAgICAgICBlZGl0SGFuZGxlSW5kZXgsXG4gICAgICAgICAgbWFwQ29vcmRzOiBldmVudC5tYXBDb29yZHMsXG4gICAgICAgIH0pO1xuICAgICAgICBvbkVkaXQoe1xuICAgICAgICAgIGVkaXRUeXBlLFxuICAgICAgICAgIHVwZGF0ZWREYXRhLFxuICAgICAgICAgIGVkaXRDb250ZXh0OiBudWxsLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlUG9pbnRlck1vdmUoZXZlbnQ6IFBvaW50ZXJNb3ZlRXZlbnQsIHByb3BzOiBNb2RlUHJvcHM8RmVhdHVyZUNvbGxlY3Rpb24+KSB7XG4gICAgLy8gbm8gc2VsZWN0ZWQgZmVhdHVyZVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBzZWxlY3RlZEZlYXR1cmUgPSB0aGlzLmdldFNlbGVjdGVkRmVhdHVyZShwcm9wcyk7XG4gICAgaWYgKCFzZWxlY3RlZEZlYXR1cmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmICghZXZlbnQuaXNEcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2hhbmRsZURyYWdnaW5nKGV2ZW50LCBwcm9wcyk7XG4gIH1cblxuICAvLyBUT0RPIC0gcmVmYWN0b3JcbiAgX3VwZGF0ZUZlYXR1cmUocHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4sIHR5cGU6IHN0cmluZywgb3B0aW9uczogYW55ID0ge30pIHtcbiAgICBjb25zdCB7IGRhdGEsIHNlbGVjdGVkSW5kZXhlcywgdmlld3BvcnQgfSA9IHByb3BzO1xuXG4gICAgY29uc3QgZmVhdHVyZUluZGV4ID0gc2VsZWN0ZWRJbmRleGVzICYmIHNlbGVjdGVkSW5kZXhlc1swXTtcbiAgICBjb25zdCBmZWF0dXJlID0gdGhpcy5nZXRTZWxlY3RlZEZlYXR1cmUocHJvcHMsIGZlYXR1cmVJbmRleCk7XG5cbiAgICBsZXQgZ2VvbWV0cnkgPSBudWxsO1xuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gZ2V0RmVhdHVyZUNvb3JkaW5hdGVzKGZlYXR1cmUpO1xuICAgIGlmICghY29vcmRpbmF0ZXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBsZXQgbmV3Q29vcmRpbmF0ZXMgPSBbLi4uY29vcmRpbmF0ZXNdO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdlZGl0SGFuZGxlJzpcbiAgICAgICAgY29uc3QgcG9zaXRpb25JbmRleGVzID1cbiAgICAgICAgICBmZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT09IEdFT0pTT05fVFlQRS5QT0xZR09OXG4gICAgICAgICAgICA/IFswLCBvcHRpb25zLmVkaXRIYW5kbGVJbmRleF1cbiAgICAgICAgICAgIDogW29wdGlvbnMuZWRpdEhhbmRsZUluZGV4XTtcblxuICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZUZlYXR1cmVDb2xsZWN0aW9uKGRhdGEpXG4gICAgICAgICAgLnJlcGxhY2VQb3NpdGlvbihmZWF0dXJlSW5kZXgsIHBvc2l0aW9uSW5kZXhlcywgb3B0aW9ucy5tYXBDb29yZHMpXG4gICAgICAgICAgLmdldE9iamVjdCgpO1xuXG4gICAgICBjYXNlICdmZWF0dXJlJzpcbiAgICAgICAgY29uc3QgeyBkeCwgZHkgfSA9IG9wdGlvbnM7XG5cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBuZXdDb29yZGluYXRlcyA9IG5ld0Nvb3JkaW5hdGVzXG4gICAgICAgICAgLm1hcCgobWFwQ29vcmRzKSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBwaXhlbHMgPSB2aWV3cG9ydCAmJiB2aWV3cG9ydC5wcm9qZWN0KG1hcENvb3Jkcyk7XG4gICAgICAgICAgICBpZiAocGl4ZWxzKSB7XG4gICAgICAgICAgICAgIHBpeGVsc1swXSArPSBkeDtcbiAgICAgICAgICAgICAgcGl4ZWxzWzFdICs9IGR5O1xuICAgICAgICAgICAgICByZXR1cm4gdmlld3BvcnQgJiYgdmlld3BvcnQudW5wcm9qZWN0KHBpeGVscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgIGdlb21ldHJ5ID0ge1xuICAgICAgICAgIHR5cGU6IGZlYXR1cmUuZ2VvbWV0cnkudHlwZSxcbiAgICAgICAgICBjb29yZGluYXRlczpcbiAgICAgICAgICAgIGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gR0VPSlNPTl9UWVBFLlBPTFlHT05cbiAgICAgICAgICAgICAgPyBbbmV3Q29vcmRpbmF0ZXNdXG4gICAgICAgICAgICAgIDogZmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSBHRU9KU09OX1RZUEUuUE9JTlRcbiAgICAgICAgICAgICAgPyBuZXdDb29yZGluYXRlc1swXVxuICAgICAgICAgICAgICA6IG5ld0Nvb3JkaW5hdGVzLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXcgSW1tdXRhYmxlRmVhdHVyZUNvbGxlY3Rpb24oZGF0YSlcbiAgICAgICAgICAucmVwbGFjZUdlb21ldHJ5KGZlYXR1cmVJbmRleCwgZ2VvbWV0cnkpXG4gICAgICAgICAgLmdldE9iamVjdCgpO1xuXG4gICAgICBjYXNlICdyZWN0YW5nbGUnOlxuICAgICAgICAvLyBtb3ZlZCBlZGl0SGFuZGxlSW5kZXggYW5kIGRlc3RpbmF0aW9uIG1hcENvb3Jkc1xuICAgICAgICBuZXdDb29yZGluYXRlcyA9IHVwZGF0ZVJlY3RhbmdsZVBvc2l0aW9uKFxuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBmZWF0dXJlLFxuICAgICAgICAgIG9wdGlvbnMuZWRpdEhhbmRsZUluZGV4LFxuICAgICAgICAgIG9wdGlvbnMubWFwQ29vcmRzXG4gICAgICAgICk7XG4gICAgICAgIGdlb21ldHJ5ID0ge1xuICAgICAgICAgIHR5cGU6IEdFT0pTT05fVFlQRS5QT0xZR09OLFxuICAgICAgICAgIGNvb3JkaW5hdGVzOiBuZXdDb29yZGluYXRlcyxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZUZlYXR1cmVDb2xsZWN0aW9uKGRhdGEpXG4gICAgICAgICAgLnJlcGxhY2VHZW9tZXRyeShmZWF0dXJlSW5kZXgsIGdlb21ldHJ5KVxuICAgICAgICAgIC5nZXRPYmplY3QoKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgbmV3IEltbXV0YWJsZUZlYXR1cmVDb2xsZWN0aW9uKGRhdGEpLmdldE9iamVjdCgpO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRQb2ludE9uU2VnbWVudChmZWF0dXJlOiBGZWF0dXJlLCBwaWNrZWQ6IGFueSwgcGlja2VkTWFwQ29vcmRzOiBQb3NpdGlvbikge1xuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gZ2V0RmVhdHVyZUNvb3JkaW5hdGVzKGZlYXR1cmUpO1xuICAgIGlmICghY29vcmRpbmF0ZXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzcmNWZXJ0ZXhJbmRleCA9IHBpY2tlZC5pbmRleDtcbiAgICBjb25zdCB0YXJnZXRWZXJ0ZXhJbmRleCA9IHBpY2tlZC5pbmRleCArIDE7XG4gICAgcmV0dXJuIGZpbmRDbG9zZXN0UG9pbnRPbkxpbmVTZWdtZW50KFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgY29vcmRpbmF0ZXNbc3JjVmVydGV4SW5kZXhdLFxuICAgICAgY29vcmRpbmF0ZXNbdGFyZ2V0VmVydGV4SW5kZXhdLFxuICAgICAgcGlja2VkTWFwQ29vcmRzXG4gICAgKTtcbiAgfVxuXG4gIF9nZXRDdXJzb3JFZGl0SGFuZGxlKGV2ZW50OiBQb2ludGVyTW92ZUV2ZW50LCBmZWF0dXJlOiBGZWF0dXJlKSB7XG4gICAgLy8gZXZlbnQgY2FuIGJlIG51bGwgd2hlbiB0aGUgdXNlciBoYXMgbm90IGludGVyYWN0ZWQgd2l0aCB0aGUgbWFwIHdoYXRzb2V2ZXJcbiAgICAvLyBhbmQgdGhlcmVmb3JlIHByb3BzLmxhc3RQb2ludGVyTW92ZUV2ZW50IGlzIHN0aWxsIG51bGxcbiAgICAvLyByZXR1cm5pbmcgbnVsbCBoZXJlIG1lYW5zIHdlIGNhbiBlLmcuIHNldCBhIGZlYXR1cmVJbmRleCB3aXRob3V0IHJlcXVpcmluZyBhbiBldmVudFxuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCB7IGlzRHJhZ2dpbmcsIHBpY2tzIH0gPSBldmVudDtcbiAgICAvLyBpZiBub3QgcGljayBzZWdtZW50XG4gICAgY29uc3QgcGlja2VkID0gcGlja3MgJiYgcGlja3NbMF07XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmICghcGlja2VkIHx8ICFpc051bWVyaWMocGlja2VkLmZlYXR1cmVJbmRleCkgfHwgcGlja2VkLnR5cGUgIT09IEVMRU1FTlRfVFlQRS5TRUdNRU5UKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBpZiBkcmFnZ2luZyBvciBmZWF0dXJlIGlzIG5laXRoZXIgcG9seWdvbiBub3IgbGluZSBzdHJpbmdcbiAgICBpZiAoXG4gICAgICBpc0RyYWdnaW5nIHx8XG4gICAgICAoZmVhdHVyZS5nZW9tZXRyeS50eXBlICE9PSBHRU9KU09OX1RZUEUuUE9MWUdPTiAmJlxuICAgICAgICBmZWF0dXJlLmdlb21ldHJ5LnR5cGUgIT09IEdFT0pTT05fVFlQRS5MSU5FX1NUUklORylcbiAgICApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGluc2VydE1hcENvb3JkcyA9IHRoaXMuX2dldFBvaW50T25TZWdtZW50KGZlYXR1cmUsIHBpY2tlZCwgZXZlbnQubWFwQ29vcmRzKTtcblxuICAgIGlmICghaW5zZXJ0TWFwQ29vcmRzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBndWlkZVR5cGU6IEdVSURFX1RZUEUuQ1VSU09SX0VESVRfSEFORExFLFxuICAgICAgICBzaGFwZTogZmVhdHVyZS5wcm9wZXJ0aWVzLnNoYXBlLFxuICAgICAgICBwb3NpdGlvbkluZGV4ZXM6IFstMV0sXG4gICAgICAgIGVkaXRIYW5kbGVUeXBlOiAnaW50ZXJtZWRpYXRlJyxcbiAgICAgIH0sXG4gICAgICBnZW9tZXRyeToge1xuICAgICAgICB0eXBlOiBHRU9KU09OX1RZUEUuUE9JTlQsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBpbnNlcnRNYXBDb29yZHMsXG4gICAgICB9LFxuICAgIH07XG4gIH1cbiAgLy8gQHRzLWlnbm9yZVxuICBnZXRHdWlkZXMocHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3Qgc2VsZWN0ZWRGZWF0dXJlID0gdGhpcy5nZXRTZWxlY3RlZEZlYXR1cmUocHJvcHMpO1xuICAgIGNvbnN0IHNlbGVjdGVkRmVhdHVyZUluZGV4ID0gcHJvcHMuc2VsZWN0ZWRJbmRleGVzICYmIHByb3BzLnNlbGVjdGVkSW5kZXhlc1swXTtcblxuICAgIGlmICghc2VsZWN0ZWRGZWF0dXJlIHx8IHNlbGVjdGVkRmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSBHRU9KU09OX1RZUEUuUE9JTlQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGV2ZW50ID0gcHJvcHMubGFzdFBvaW50ZXJNb3ZlRXZlbnQ7XG5cbiAgICAvLyBmZWF0dXJlIGVkaXRIYW5kbGVzXG4gICAgY29uc3QgZWRpdEhhbmRsZXMgPSB0aGlzLmdldEVkaXRIYW5kbGVzRnJvbUZlYXR1cmUoc2VsZWN0ZWRGZWF0dXJlLCBzZWxlY3RlZEZlYXR1cmVJbmRleCkgfHwgW107XG5cbiAgICAvLyBjdXJzb3IgZWRpdEhhbmRsZVxuICAgIGNvbnN0IGN1cnNvckVkaXRIYW5kbGUgPSB0aGlzLl9nZXRDdXJzb3JFZGl0SGFuZGxlKGV2ZW50LCBzZWxlY3RlZEZlYXR1cmUpO1xuICAgIGlmIChjdXJzb3JFZGl0SGFuZGxlKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBlZGl0SGFuZGxlcy5wdXNoKGN1cnNvckVkaXRIYW5kbGUpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgZmVhdHVyZXM6IGVkaXRIYW5kbGVzLmxlbmd0aCA/IGVkaXRIYW5kbGVzIDogbnVsbCxcbiAgICB9O1xuICB9XG59XG4iXX0=